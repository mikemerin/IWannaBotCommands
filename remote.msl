/*
--Help Commands--
*/

on *:TEXT:!commands:*: {
  if (!%comwaitcommands) {
    set -u15 %comwaitcommands 1
    msg $chan (⌐■_■)⌐ The commands you can use are: !fangame !discord !intro !jumps !game !schedule !next
  }
}


/*
--Repeated Messages--
*/

on *:TEXT:!repeat_on:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon) {
    msg $chan /me (⌐■_■)⌐ Repeated commands loaded!
    timer 1 5 rFollow
    timer 1 20 rDiscord
    timer 1 35 rIntro
    timer 1 50 rFangame
  }
}

on *:TEXT:!repeat_off:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon) {
    /timerfollow off
    /timerchatran off
    /timerdiscord off
    /timerintro off
    /timerfangame off
    /timerrepeat off
    /timerschedule off
    /timernext off
    /timergame off
    msg $chan ( •_•)>⌐■-■ Repeated commands are now off.
  }
}

alias rFollow {
  /timerfollow 0 660 msg $chan /me (⌐■_■)⌐ Enjoying the run? Be sure to follow the runner(s) by clicking the relevant FFZ follow buttons below the stream!
}

alias rDiscord {
  /timerdiscord 0 840 msg $chan /me (⌐■_■)⌐ Join our Discord server! https://discord.gg/wW4axZp
}

alias rIntro {
  /timersintro 0 1020 msg $chan /me (⌐■_■)⌐ New to IWBTG fangames and curious about what you're watching? Head over to https://fangam.es/intro for a nice overview!
}

alias rFangame {
  /timerfangame 0 1140 msg $chan /me (⌐■_■)⌐ To download some fangames visit https://fangam.es and search our immense list of free games! To learn more about fangames type !intro
}


on *:TEXT:!repeat_follow:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == iwannabot) {
    msg $chan (⌐■_■)⌐ Enjoying the run? Be sure to follow the runner(s) by clicking the relevant FFZ follow buttons below the stream!
    rFollow

  }
}

on *:TEXT:!repeat_discord:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == iwannabot) {
    msg $chan (⌐■_■)⌐ Join our Discord server! https://discord.gg/wW4axZp
    rDiscord
  }
}

on *:TEXT:!repeat_intro:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == iwannabot) {
    msg $chan (⌐■_■)⌐ New to IWBTG fangames and curious about what you're watching? Head over to https://fangam.es/intro for a nice overview!
    rIntro
  }
}

on *:TEXT:!repeat_fangame:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == iwannabot) {
    msg $chan (⌐■_■)⌐ To download some fangames visit https://fangam.es and search our immense list of free games! To learn more about fangames type !intro
    rFangame
  }
}


/*
--Update FFZ Icons--
*/

on *:TEXT:!update *:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == joshua_boring || $nick == wolsk || $nick == denferok || $nick == cakesauc3 || $nick == krakkacafe || $nick == piranhatooth || $nick == pieceofcheese87 || $nick == artardss || $nick == naloas || $nick == pandy49  || $nick == onychu) {
    set %url https://horaro.org/-/api/v1/schedules/3e11t8e3x52bgh7a8d/ticker
    /JSONOpen -ud schedule %url
    var %curr_game = $JSON(schedule, data, ticker, $2, data, 0)
    var %curr_type = $JSON(schedule, data, ticker, $2, data, 1)
    var %curr_name = $JSON(schedule, data, ticker, $2, data, 3)

    $regex(name, %curr_name, /twitch.tv/([a-zA-Z0-9|_]+)/g)

    if ($regml(name, 0) > 1) {
      $regex(link, %curr_name, /twitch.tv/([a-zA-Z0-9|_]+)/g)
      set %names $regml(name, 0) + 1
      set %pos 1
      set %name_parsed
      while (%pos < %names) {
        set %name_parsed %name_parsed $regml(link, %pos)
        set %sum %names - %pos
        set %pos %pos + 1
      }
    }
    else if ($regml(name, 0) > 0) {
      $regex(link, %curr_name, /twitch.tv/([a-zA-Z0-9|_]+)/)
      set %name_parsed $regml(link, 1)

    }
    else {
      set %name_parsed %curr_name
    }
    msg $chan !ffzfollow %name_parsed
  }
}

/*
--General Commands--
*/

on *:TEXT:!fangame:*: {
  if (!%comwaitfangame) {
    set -u15 %comwaitfangame 1
    msg $chan (⌐■_■)⌐ To download some fangames visit https://fangam.es and search our immense list of free games! To learn more about fangames type !intro
  }
}

on *:TEXT:!fangames:*: {
  if (!%comwaitfangame) {
    set -u15 %comwaitfangame 1
    msg $chan (⌐■_■)⌐ To download some fangames visit https://fangam.es and search our immense list of free games! To learn more about fangames type !intro
  }
}

on *:TEXT:!discord:*: {
  if (!%comwaitintro) {
    set -u15 %comwaitdiscord 1
    msg $chan (⌐■_■)⌐ Join our Discord server! https://discord.gg/wW4axZp
  }
}

on *:TEXT:!intro:*: {
  if (!%comwaitintro) {
    set -u15 %comwaitintro 1
    msg $chan (⌐■_■)⌐ New to IWBTG fangames and curious about what you're watching? Head over to https://fangam.es/intro for a nice overview!
  }
}

on *:TEXT:!jumps:*: {
  if (!%comwaitjumps) {
    set -u20 %comwaitjumps 1
    msg $chan (⌐■_■)⌐ Here are a list of the major jumps used in fangames http://puu.sh/k8lSk/4678139789.png
  }
}


/*
--Game Info with Link--
*/

Alias game_alias {
  if (!%comwaitgame) {
    set -u20 %comwaitgame 1
    set %url https://horaro.org/-/api/v1/schedules/3e11t8e3x52bgh7a8d/ticker
    /JSONOpen -ud schedule %url
    var %game = $JSON(schedule, data, ticker, current, data, 0)
    $regex(game, %game, /\[(.+)(?=\])/)
    if ($regml(game, 0) > 0) {
      set %game_parsed $regml(game, 1)
      $regex(link, %game, /\](\(.+\))/)
      set %linkb $regml(link, 1)
      set %linkblen $len(%linkb) - 1
      set %link $left($right(%linkb, %linkblen), -1)
      set %game_parsed %game_parsed %link
    }
    else {
      set %game_parsed %game
    }
    set %glen $len(%game_parsed)
    if ( %glen == 0 ) {
      msg $chan (⌐■﹏■) We're in between games!
    }
    else {
      msg $chan (⌐■_■)⌐ Current game: %game_parsed
    }
  }
}

on *:TEXT:!game:*: {
  game_alias
}


/*
--Schedule (current/next)--
*/

on *:TEXT:!schedule:*: {
  if (!%comwaitschedule) {
    set -u20 %comwaitschedule 1
    msg $chan (⌐■_■)⌐ Schedule: https://horaro.org/fm/2021

    set %url https://horaro.org/-/api/v1/schedules/3e11t8e3x52bgh7a8d/ticker
    /JSONOpen -ud schedule %url
    var %curr_game = $JSON(schedule, data, ticker, current, data, 0)
    var %curr_type = $JSON(schedule, data, ticker, current, data, 1)
    var %curr_name = $JSON(schedule, data, ticker, current, data, 3)

    $regex(game, %curr_game, /\[(.*?)\]/)
    if ($regml(game, 0) > 0) {
      set %game_parsed $regml(game, 1)
      ;      $regex(link, %game, /\](\(.+\))/)
      ;      set %game_parsed %game_parsed $regml(link, 1)
    }
    else {
      set %game_parsed %curr_game
    }
    $regex(name, %curr_name, /\[(.*?)\]/g)

    if ($regml(name, 0) > 1) {
      $regex(link, %curr_name, /\((.*?)\)/g)
      set %names $regml(name, 0) + 1
      set %pos 1
      set %name_parsed
      while (%pos < %names) {
        set %name_parsed %name_parsed $regml(name, %pos)
        set %name_parsed %name_parsed $regml(link, %pos)
        set %sum %names - %pos
        if (%sum == 2) {
          set %name_parsed %name_parsed and
        }
        set %pos %pos + 1
      }
    }
    else if ($regml(name, 0) > 0) {
      $regex(link, %curr_name, /\((.*?)\)/)
      set %name_parsed $regml(name, 1)
      set %name_parsed %name_parsed $regml(link, 1)

    }
    else {
      set %name_parsed %curr_name
    }

    set %glen $len(%game_parsed)
    if ( %glen == 0 ) {
      msg $chan (⌐■﹏■) We're in between games!
    }
    else {
      msg $chan (⌐■_■)⌐ Current run: %game_parsed %curr_type by %name_parsed
    }
  }
}

on *:TEXT:!next:*: {
  if (!%comwaitnext) {
    set -u20 %comwaitnext 1
    ;  set %url https://horaro.org/-/api/v1/events/testschedulemike/schedules/schedule/ticker
    set %url https://horaro.org/-/api/v1/schedules/4211o6degx4bji7a30/ticker
    /JSONOpen -ud schedule %url


    var %next_game = $JSON(schedule, data, ticker, next, data, 0)
    var %next_type = $JSON(schedule, data, ticker, next, data, 1)
    var %next_name = $JSON(schedule, data, ticker, next, data, 3)

    ;  msg $chan Current run: %game %type by %name
    $regex(game, %next_game, /\[(.*?)\]/)
    if ($regml(game, 0) > 0) {
      set %game_parsed $regml(game, 1)
      ;      $regex(link, %game, /\](\(.+\))/)
      ;      set %game_parsed %game_parsed $regml(link, 1)
    }
    else {
      set %game_parsed %next_game
    }
    $regex(name, %next_name, /\[(.*?)\]/g)
    if ($regml(name, 0) > 1) {
      $regex(link, %next_name, /\((.*?)\)/g)
      set %names $regml(name, 0) + 1
      set %pos 1
      set %name_parsed
      while (%pos < %names) {
        set %name_parsed %name_parsed $regml(name, %pos)
        set %name_parsed %name_parsed $regml(link, %pos)
        set %sum %names - %pos
        if (%sum == 2) {
          set %name_parsed %name_parsed and
        }
        set %pos %pos + 1
      }
    }
    else if ($regml(name, 0) > 0) {
      $regex(link, %next_name, /\((.*?)\)/)
      set %name_parsed $regml(name, 1)
      set %name_parsed %name_parsed $regml(link, 1)
    }
    else {
      set %name_parsed %next_name
    }


    set %glen $len(%game_parsed)
    if ( %glen == 0 ) {
      msg $chan ( •_•)>⌐■-■ No game is next :(
    }
    else {
      msg $chan (⌐■_■)⌐ Next run: %game_parsed %next_type by %name_parsed
    }
    /*
    set %url https://horaro.org/-/api/v1/schedules/4211o6degx4bji7a30/ticker
    /JSONOpen -ud schedule %url
    var %prev_game = $JSON(schedule, data, items, 0, data, 0)
    var %prev_type = $JSON(schedule, data, items, 0, data, 1)
    var %prev_name = $JSON(schedule, data, items, 0, data, 2)
    msg $chan Current run: %prev_game %prev_type by %prev_name
    var %next_game = $JSON(schedule, data, items, 8, data, 0)
    var %next_type = $JSON(schedule, data, items, 8, data, 1)
    var %next_name = $JSON(schedule, data, items, 8, data, 2)
    msg $chan Next run: %next_game %next_type by %next_name
    */
  }

}


/*
--Admin Commands
*/

on *:TEXT:!a_delete:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon) {
    unset %admins
    msg $chan /me ( •_•)>⌐■-■ Admins deleted.
  }
}

on *:TEXT:!a_create:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon) {
    set %admins. $+ shadowsdieaway true
    set %admins. $+ wolsk true
    set %admins. $+ denferok true
    set %admins. $+ fangamemarathon true
    msg $chan /me (⌐■_■)⌐ Admins added.
  }
}

on *:TEXT:!a_check:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon) {
    if ( %admins. [ $+ [ $nick ] ] ) {
      msg $chan /me (⌐■_■)⌐ %admins. $+ $nick is an admin
    }
    else {
      msg $chan /me (⌐■﹏■) %admins. $+ $nick is not an admin
    }
  }
}


/*
--Voting--
*/

Alias top_votes {
  set %ix 1
  set %iy 1
  set %top_x
  set %top_x_n 0
  set %top_y
  set %top_y_n 0
  while ($hget(votes_x, %ix).item) {
    set %vx $v1
    if ($hget(votes_x, %vx) > %top_x_n) {
      set %top_x %vx
      set %top_x_n $hget(votes_x, %vx)
    }
    else if ($hget(votes_x, %vx) == %top_x_n) {
      set %top_x %top_x  $+ / $+ %vx
    }
    inc %ix
  }
  ;      msg $chan /w shadowsdieaway Top X: %top_x with %top_x_n
  msg $chan /me (⌐■_■)⌐ Top X: %top_x with %top_x_n vote(s)
  while ($hget(votes_y, %iy).item) {
    set %vy $v1
    if ($hget(votes_y, %vy) > %top_y_n) {
      set %top_y %vy
      set %top_y_n $hget(votes_y, %vy)
    }
    else if ($hget(votes_y, %vy) == %top_y_n) {
      set %top_y %top_y $+ / $+ %vy
    }
    inc %iy
  }
  ;      msg $chan /w shadowsdieaway Top Y: %top_y with %top_y_n
  msg $chan /me (⌐■_■)⌐ Top Y: %top_y with %top_y_n vote(s)
  unset %ix
  unset %iy
  unset %vx
  unset %vy
  unset %top_x
  unset %top_y
}

Alias top_votes_list {
  set %ix 1
  set %iy 1
  set %top_x_list Current X votes:
  set %top_y_list Current Y votes:
  while ($hget(votes_x, %ix).item) {
    set %vx $v1
    set %top_x_list %top_x_list %vx ( $+ $hget(votes_x, %vx) $+ )
    inc %ix
    if ($hget(votes_x, %ix).item) { set %top_x_list %top_x_list $+ , }
  }
  while ($hget(votes_y, %iy).item) {
    set %vy $v1
    set %top_y_list %top_y_list %vy ( $+ $hget(votes_y, %vy) $+ )
    inc %iy
  }
  msg $chan /me (⌐■_■)⌐ %top_x_list
  msg $chan /me (⌐■_■)⌐ %top_y_list
  unset %ix
  unset %iy
  unset %vx
  unset %vy
  unset %top_x_list
  unset %top_y_list
}

Alias top_votes_list_percentage {
  set %i 1
  set %total 0
  set %top_list Current votes:
  while ($hget(votes, %i).item) {
    set %v $v1
    set %top_list %top_list %v ( $+ $hget(votes, %v) $+ )
    inc %i
    if ($hget(votes, %i).item) { set %top_list %top_list $+ , }
  }
  msg $chan /me (⌐■_■)⌐ %top_list
  unset %i
  unset %v
  unset %top_list
}

on *:TEXT:!vote help:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == pieceofcheese87) {
    msg $chan /me (⌐■_■)つ v_create: creates the voting system. v_delete: deletes the voting system. v_reset: reset all votes. v_info [top|list|users]: top votes|list all votes|list all users with their votes. v_check [*user]: check a specific user's vote. v_start: start the voting. vote [x] [y]: vote!
  }
  else {
    if (!%comwait) {
      set -u10 %comwait 1
      msg $chan /me (つ■_■)つ┌┬┐ When voting is open type "!vote [letter]"
      msg $chan /me (つ■_■)つ├┼┤ You can vote A through Y
      msg $chan /me (つ■_■)つ└┴┘ Lowercase or uppercase does not matter
    }
  }
}

on *:TEXT:!v_create:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == pieceofcheese87) {
    set %v_open false
    set %v_system true
    set %runnerA
    set %runnerB
    hmake votes
    hmake votes_u
    msg $chan /me (⌐■_■)⌐ Voting system created.
  }
}

on *:TEXT:!v_delete:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == pieceofcheese87) {
    unset %u*
    unset %v_open
    set %v_system false
    hfree votes
    hfree votes_u
    msg $chan /me ( •_•)>⌐■-■ Voting system has been deleted.
  }
}

on *:TEXT:!v_reset:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == pieceofcheese87) {
    unset %u*
    set %v_open false
    hfree votes
    hfree votes_u
    hmake votes
    hmake votes_u
    msg $chan /me (⌐■_■)⌐ The vote count has been reset to $var(%u.*) $+ .
  }
}

on *:TEXT:!v_info *:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == pieceofcheese87) {
    set %num 0
    if ($var(%u.*) == 0) {
      msg $chan /me (⌐■﹏■) No one has voted yet.
    }
    else if ($2 == top) {
      top_votes
    }
    else if ($2 == list) {
      top_votes_list_percentage
    }
    else if ($2 == users) {
      set %vote_list /me (⌐■_■)⌐ Total users that voted: $var(%u.*) -
      while (%num < $var(%u.*)) {
        %num = %num + 1
        set %user $right($var(%u.*,%num),-3)
        set %vote_list %vote_list %user ( $+ $hget( votes_u, %user ) $+ )
        if (%num < $var(%u.*)) { set %vote_list %vote_list $+ , }
        unset %user
      }
      msg $chan %vote_list
      unset %vote_list
    }
    unset %num
  }
}

on *:TEXT:!v_check *:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == pieceofcheese87) {
    if ( %u. [ $+ [ $2 ] ] ) {
      msg $chan /me (⌐■_■)⌐ %u. $+ $2 has voted $hget( votes_u, $2 )
    }
    else {
      msg $chan /me (⌐■﹏■) %u. $+ $2 has not voted yet.
    }
  }
}

on *:TEXT:!v_set_runners *:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == pieceofcheese87) {
    set %runnerA $2
    msg $chan /me (⌐■_■)⌐ A votes set to $2
    set %runnerB $3
    msg $chan /me (⌐■_■)⌐ B votes set to $3
  }
}

on *:TEXT:!v_start:*: {
  if ($nick == shadowsdieaway || $nick == fangamemarathon || $nick == pieceofcheese87) {
    set %v_open true
    msg $chan /me (⌐■_■)⌐ Voting is open for 30 seconds!


    timer 1 10 msg $chan /me (⌐■_■)⌐ 20 seconds remaining!
    timer 1 20 msg $chan /me (⌐■_■)⌐ 10 seconds remaining!
    timer 1 25 msg $chan /me (⌐■_■)⌐ 5 seconds remaining!
    timer 1 30 set %v_open false
    timer 1 30 msg $chan /me (⌐■_■)⌐ Voting is now closed!
  }
}

on *:TEXT:!vote *:*: {
  set %user_vote $upper( $2 )
  if (%v_system == false) {
    ;      msg $chan /me (⌐■﹏■) Sorry we're not voting now!
  }
  else if (%v_open == false) {
    ;      msg $chan /me (⌐■﹏■) Sorry $nick voting is closed.
  }
  else if (%u. [ $+ [ $nick ] ] ) {
    msg $chan /me (⌐■﹏■) Sorry $nick you already voted $hget( votes_u, $nick )
  }
  else if ( %user_vote == A || %user_vote == B || %user_vote == C || %user_vote == D || %user_vote == E || %user_vote == F || %user_vote == G || %user_vote == H || %user_vote == I || %user_vote == J || %user_vote == K || %user_vote == L || %user_vote == M || %user_vote == N || %user_vote == O || %user_vote == P || %user_vote == Q || %user_vote == R || %user_vote == S || %user_vote == T || %user_vote == U || %user_vote == V || %user_vote == W || %user_vote == X || %user_vote == Y) {
    set %u. $+ $nick true
    hadd votes_u $nick %user_vote
    if ($hget(votes, $2)) { set %num $hget(votes, $2) + 1 }
    else { set %num 1 }
    hadd votes $2 %num
    unset %num
    ;    msg $chan /me (⌐■_■)⌐ $nick voted $2 Current vote(s): $var(%u.*) $+ .
  }
  else {
    msg $chan /me (⌐■﹏■) $nick your vote must A through Y (upper or lowercase). Please try again.
  }
}

/*
--JSON parsing scripts below **DO NOT CHANGE** taken from https://sreject.github.io/JSON-For-Mirc/reference ?--
*/

; JSON as inputted text
alias JSON:ex1 {
  jsonopen -d test {"text":"text test"}
  echo 04 -a :: $json(test).error
  echo -a Result: $json(test, text)
}

; JSON as a bvar
alias JSON:ex2 {
  bset -t &test 1 {"bvar":"bvar test"}
  jsonopen -bd test &test
  echo 04 -a :: $json(test).error
  echo -a Result: $json(test, bvar)
}

; JSON from a file
alias JSON:ex3 {
  write -c JSONExample.txt {"file":"file test"}
  jsonopen -fd test JSONExample.txt
  echo 04 -a :: $json(test).error
  echo -a Result: $json(test, file)
  .remove JSONExample.txt
}

; JSON from a url
alias JSON:ex4 {
  jsonopen -ud test http://ajax.googleapis.com/ajax/services/search/web?v=1.0&safe=active&rsz=3&q=JSON%20for%20mIRC
  echo 04 -a :: $json(test).error
  echo -a Result: $json(test, responseData, results, 0, titleNoFormatting) - $json(test, responseData, results, 0, url)
}

; Index-key values (indexes start at 0, not 1)
alias JSON:ex5 {
  jsonopen -d test ["index0", "index1", "index2"]
  echo 04 -a :: $json(test).error
  echo -a Result:
  echo -a #0: $json(test, 0)
  echo -a #1: $json(test, 1)
  echo -a #2: $json(test, 2)
}

; Nested members
alias JSON:ex6 {
  jsonopen -d test ["index0",[{"key":"value","arr":["nested value"]}]]
  echo 04 -a :: $json(test).error
  echo -a Result
  echo -a :: $json(test, 1, 0, arr, 0)
}
Code:

alias JSONVersion {
  if ($isid) {
    return $iif($1 != short,JSONForMirc v,v) $+ 0.2.2
  }
}
alias JSONError {
  if ($isid) {
    return %JSONError
  }
}
alias JSONOpen {
  if ($isid) return
  unset %JSONError
  debugger -i 0 Calling /JSONOpen $1-
  var %switches = -, %error, %com, %file
  if (-* iswm $1) {
    %switches = $1
    tokenize 32 $2-
  }
  if ($regex(%switches, ([^dbfuw\-]))) {
    %error = Invalid switches specified: $regml(1)
  }
  elseif ($regex(%switches, ([dbfuw]).*?\1)) {
    %error = Duplicate switch specified: $regml(1)
  }
  elseif ($regex(%switches, /([bfu])/g) > 1) {
    %error = Conflicting switches: $regml(1) $+ , $regml(2)
  }
  elseif (u !isin %switches && w isin %switches) {
    %error = -w switch can only be used with -u
  }
  elseif ($0 < 2) {
    %error = Missing Parameters
  }
  elseif (!$regex($1, /^[a-z][a-z\d_.-]+$/i)) {
    %error = Invalid handler name: Must start with a letter and contain only letters numbers _ . and -
  }
  elseif ($com(JSONHandler:: $+ $1)) {
    %error = Name in use
  }
  elseif (b isin %switches && $0 != 2) {
    %error = Invalid parameter: Binary variable names cannot contain spaces
  }
  elseif (b isin %switches && &* !iswm $2) {
    %error = Invalid parameters: Binary variable names start with &
  }
  elseif (b isin %switches && !$bvar($2, 0)) {
    %error = Invalid parameters: Binary variable is empty
  }
  elseif (f isin %switches && !$isfile($2-)) {
    %error = Invalid parameters: File doesn't exist
  }
  elseif (f isin %switches && !$file($2-).size) {
    %error = Invalid parameters: File is empty
  }
  elseif (u isin %switches && $0 != 2) {
    %error = Invalid parameters: URLs cannot contain spaces
  }
  else {
    .comopen JSONHandler:: $+ $1 MSScriptControl.ScriptControl
    if (!$com(JSONHandler:: $+ $1) || $comerr) {
      %error = Unable to create an instance of MSScriptControl.ScriptControl
    }
    else {
      %com = JSONHandler:: $+ $1
      if (!$com(%com, language, 4, bstr, jscript) || $comerr) {
        %error = Unable to set ScriptControl's language to Javascript
      }
      elseif (!$com(%com, timeout, 4, bstr, 60000) || $comerr) {
        %error = Unable to set ScriptControl's timeout to 60seconds
      }
      elseif (!$com(%com, ExecuteStatement, 1, bstr, $JScript) || $comerr) {
        %error = Unable to add required javascript to the ScriptControl instance
      }
      elseif (u isincs %switches) {
        if (1 OK != $jstry(%com, $jscript(urlInit), $escape($2-).quote)) {
          %error = $gettok($v2, 2-, 32)
        }
        elseif (w !isincs %switches && 0 ?* iswm $jsTry(%com, $jscript(urlParse), status="error").withError) {
          %error = $gettok($v2, 2-, 32)
        }
      }
      elseif (f isincs %switches) {
        if (1 OK != $jstry(%com, $jscript(fileParse), $escape($longfn($2-)).quote)) {
          %error = $gettok($v2, 2-, 32)
        }
      }
      elseif (b isincs %switches) {
        %file = $tempfile
        bwrite $qt(%file) -1 -1 $2
        debugger %com Wrote $2 to $qt(%file)
        if (0 ?* iswm $jstry(%com, $jscript(fileParse), $escape(%file).quote)) {
          %error = $gettok($v2, 2-, 32)
        }
      }
      else {
        %file = $tempfile
        write -n $qt(%file) $2-
        debugger %com Wrote $2- to $qt(%file)
        if (0 ?* iswm $jstry(%com, $jscript(fileParse), $escape(%file).quote)) {
          %error = $gettok($v2, 2-, 32)
        }
      }
      if (!%error) {
        if (d isin %switches) {
          $+(.timer, %com) -o 1 0 JSONClose $1
        }
        Debugger -s %com Successfully created
      }
    }
  }
  :error
  %error = $iif($error, $error, %error)
  reseterror
  if (%file && $isfile(%file)) {
    .remove $qt(%file)
    debugger %com Removed $qt(%file)
  }
  if (%error) {
    if (%com && $com(%com)) {
      .comclose %com
    }
    set -eu0 %JSONError %error
    Debugger -e 0 /JSONOpen %switches $1- --RAISED-- %error
  }
}
alias JSONUrlMethod {
  if ($isid) return
  unset %JSONError
  debugger -i 0 Calling /JSONUrlMethod $1-
  var %error, %com
  if ($0 < 2) {
    %error = Missing parameters
  }
  elseif ($0 > 2) {
    %error = Too many parameters specified
  }
  elseif (!$regex($1, /^[a-z][a-z\d_.\-]+$/i)) {
    %error = Invalid handler name: Must start with a letter and contain only letters numbers _ . and -
  }
  elseif (!$com(JSONHandler:: $+ $1)) {
    %error = Invalid handler name: JSON handler does not exist
  }
  elseif (!$regex($2, /^(?:GET|POST|PUT|DEL)$/i)) {
    %error = Invalid request method: Must be GET, POST, PUT, or DEL
  }
  else {
    var %com = JSONHandler:: $+ $1
    if (1 OK != $jsTry(%com, $JScript(UrlMethod), status="error", $qt($upper($2))).withError) {
      %error = $gettok($v2, 2-, 32)
    }
    else {
      Debugger -s $+(%com,>JSONUrlMethod) Method set to $upper($2)
    }
  }
  :error
  %error = $iif($error, $v1, %error)
  reseterror
  if (%error) {
    set -eu0 %JSONError %error
    if (%com) set -eu0 % [ $+ [ %com ] $+ ] ::Error %error
    Debugger -e $iif(%com, $v1, 0) /JSONUrlMethod %switches $1- --RAISED-- %error
  }
}
alias JSONUrlHeader {
  if ($isid) return
  unset %JSONError
  debugger -i 0 Calling /JSONUrlHeader $1-
  var %error, %com
  if ($0 < 3) {
    %error = Missing parameters
  }
  elseif (!$regex($1, /^[a-z][a-z\d_.\-]+$/i)) {
    %error = Invalid handler name: Must start with a letter and contain only letters numbers _ . and -
  }
  elseif (!$com(JSONHandler:: $+ $1)) {
    %error = Invalid handler name: JSON handler does not exist
  }
  elseif (!$regex($2, /^[a-z_-]+:?$/i)) {
    %error = Invalid header name: Header names can only contain letters, _ and -
  }
  else {
    %com = JSONHandler:: $+ $1
    if (1 OK !== $jsTry(%com, $JScript(UrlHeader), status="error", $escape($regsubex($2, :+$, )).quote, $escape($3-).quote).withError) {
      %error = $gettok($v2, 2-, 32)
    }
    else {
      Debugger -s $+(%com,>JSONUrlHeader) Header $+(',$2,') set to $3-
    }
  }
  :error
  %error = $iif($error, $v1, %error)
  reseterror
  if (%error) {
    set -eu0 %JSONError %error
    if (%com) set -eu0 % [ $+ [ %com ] $+ ] ::Error %error
    Debugger -e $iif(%com, $v1, 0) /JSONUrlMethod %switches $1- --RAISED-- %error
  }
}
alias JSONUrlOption {
  if ($isid) return
  unset %JSONError
  Debugger -i 0 /JSONUrlOption is depreciated and will be removed. Please use /JSONUrlMethod and /JSONUrlHeader
  if ($2 == method) {
    JSONUrlMethod $1 $3-
  }
  else {
    JSONUrlHeader $1-
  }
}
alias JSONUrlGet {
  if ($isid) return
  unset %JSONError
  Debugger -i 0 Calling /JSONUrlGet $1-
  var %switches = -, %error, %com, %file
  if (-* iswm $1) {
    %switches = $1
    tokenize 32 $2-
  }
  if (!$0 || (%switches != - && $0 < 2)) {
    %error = Missing parameters
  }
  elseif (!$regex(%switches, ^-[bf]?$)) {
    %error = Invalid switch(es) specified
  }
  elseif (!$regex($1, /^[a-z][a-z\d_.\-]+$/i)) {
    %error = Invalid handler name: Must start with a letter and contain only letters numbers _ . and -
  }
  elseif (!$com(JSONHandler:: $+ $1)) {
    %error = Specified handler does not exist
  }
  elseif (b isincs %switches && &* !iswm $2) {
    %error = Invalid bvar name: bvars start with &
  }
  elseif (b isincs %switches && $0 > 2) {
    %error = Invalid bvar name: Contains spaces: $2-
  }
  elseif (f isincs %switches && !$isfile($2-)) {
    %error = Specified file does not exist: $longfn($2-)
  }
  else {
    %com = JSONHandler:: $+ $1
    if ($0 > 1) {
      if (f isincs %switches) {
        if (0 ?* iswm $jsTry(%com, $JScript(UrlData), status="error", $escape($longfn($2-)).quote).withError) {
          %error = $gettok($v2, 2-, 32)
        }
        else {
          Debugger -s $+(%com,>JSONUrlGet) Stored $longfn($2-) as data to send with HTTP Request
        }
      }
      else {
        %file = $tempfile
        if (b isincs %switches) {
          bwrite $qt(%file) -1 -1 $2
        }
        else {
          write -n $qt(%file) $2-
        }
        Debugger -s $+(%com,>JSONUrlGet) Wrote specified data to %file
        if (0 ?* iswm $jsTry(%com, $JScript(UrlData), status="error", $escape(%file).quote).withError) {
          %error = $gettok($v2, 2-, 32)
        }
        else {
          Debugger -s $+(%Com,>JSONUrlGet) Stored $2- as data to send with HTTP Request
        }
        .remove $qt(%file)
      }
    }
    if (!%error) {
      if (0 ?* iswm $jsTry(%com, $JScript(URLParse), status="error").withError) {
        %error = $gettok($v2, 2-, 32)
      }
      else {
        Debugger -s $+(%com,>JSONUrlGet) Request finished
      }
    }
  }
  :error
  %error = $iif($error, $v1, %error)
  reseterror
  if (%error) {
    set -eu0 %JSONError %error
    if (%com) set -eu0 % [ $+ [ %com ] $+ ] ::Error %error
    Debugger -e $iif(%com, $v1, 0) /JSONUrlGet %switches $1- --RAISED-- %error
  }
}
alias JSONGet {
  if ($isid) return
  unset %JSONError
  debugger -i 0 /JSONGet is depreciated and will be removed. Please use /JSONUrlGet
  JSONUrlGet $1-
}
alias JSONClose {
  if ($isid) return
  unset %JSONError
  Debugger -i 0 /JSONClose $1-
  var %switches = -, %error, %com, %x
  if (-* iswm $1) {
    %switches = $1
    tokenize 32 $2-
  }
  if ($0 < 1) {
    %error = Missing parameters
  }
  elseif ($0 > 1) {
    %error = Too many parameters specified.
  }
  elseif (%switches !== - && %switches != -w) {
    %error = Unknown switches specified
  }
  elseif (%switches == -) {
    %com = JSONHandler:: $+ $1
    if ($com(%com)) { .comclose %com }
    if ($timer(%com)) { $+(.timer,%com) off }
    unset % [ $+ [ %com ] $+ ] ::Error
    Debugger -i %com Closed
  }
  else {
    %com = JSONHandler:: $+ $1
    %x = 1
    while (%x <= $com(0)) {
      if (%com iswm $com(%x)) {
        .comclose $v1
        $+(.timer,$v1) off
        unset % [ $+ [ $v1 ] $+ ] ::*
        Debugger -i %com Closed
      }
      else {
        inc %x
      }
    }
  }
  :error
  %error = $iif($error, $v1, %error)
  reseterror
  if (%error) {
    set -eu0 %JSONError %error
  }
}
alias JSONList {
  if ($isid) return
  Debugger -i 0 Calling /JSONList $1-
  var %x = 1, %i = 0
  while ($com(%x)) {
    if (JSONHandler::* iswm $v1) {
      inc %i
      echo $color(info) -a * # $+ %i : $regsubex($v2, /^JSONHandler::/, )
    }
    inc %x
  }
  if (!%i) {
    echo $color(info) -a * No active JSON handlers
  }
}
alias JSON {
  if (!$isid) {
    return
  }
  var %x, %calling, %i = 0, %com, %get = json, %ref = $false, %error, %file
  if ($JSONDebug) {
    %x = 0
    while (%x < $0) {
      inc %x
      %calling = %calling $+ $iif(%calling,$chr(44)) $($ $+ %x,2)
    }
    debugger -i 0 Calling $!JSON( $+ %calling $+ $chr(41) $+ $iif($prop,. $+ $prop)
  }
  if (!$0) {
    return
  }
  if ($regex($1, ^\d+$)) {
    %x = 1
    while ($com(%x)) {
      if (JSONHandler::* iswm $v1) {
        inc %i
        if (%i == $1) {
          %com = $com(%x)
          break
        }
      }
      inc %x
    }
    if ($0 == 1 && $1 == 0) {
      return %i
    }
  }
  elseif ($regex($1, /^[a-z][a-z\d_.-]+$/i)) {
    %com = JSONHandler:: $+ $1
  }
  elseif ($regex($1, /^(JSONHandler::[a-z][a-z\d_.-]+)::(.+)$/i)) {
    %com = $regml(1)
    %get = json $+ $regml(2)
    %ref = $true
  }
  if (!%com) {
    %error = Invalid name specified
  }
  elseif (!$com(%com)) {
    %error = Handler doesn't exist
  }
  elseif (!$regex($prop, /^(?:Status|IsRef|IsChild|Error|Data|UrlStatus|UrlStatusText|UrlHeader|Fuzzy|FuzzyPath|Type|Length|ToBvar|IsParent)?$/i)) {
    %error = Unknown prop specified
  }
  elseif ($0 == 1) {
    if ($prop == isRef) {
      return %ref
    }
    elseif ($prop == isChild) {
      Debugger -i 0 $!JSON().isChild is depreciated use $!JSON().isRef
      return %ref
    }
    elseif ($prop == status) {
      if ($com(%com, eval, 1, bstr, status) && !$comerr) {
        return $com(%com).result
      }
      else {
        %error = Unable to determine status
      }
    }
    elseif ($prop == error) {
      if ($eval($+(%,%com,::Error),2)) {
        return $v1
      }
      elseif ($com(%com, eval, 1, bstr, error) && !$comerr) {
        return $com(%com).result
      }
      else {
        %error = Unable to determine if there is an error
      }
    }
    elseif ($prop == UrlStatus || $prop == UrlStatusText) {
      if (0 ?* iswm $jsTry(%com, $JScript($prop))) {
        %error = $gettok($v2, 2-, 32)
      }
      else {
        return $v2
      }
    }
    elseif (!$prop) {
      return $regsubex(%com,/^JSONHandler::/,)
    }
  }
  elseif (!$regex($prop, /^(?:fuzzy|fuzzyPath|data|type|length|toBvar|isParent)?$/i)) {
    %error = $+(',$prop,') cannot be used when referencing items
  }
  elseif ($prop == toBvar && $chr(38) !== $left($2, 1) ) {
    %error = Invalid bvar specified: bvar names must start with &
  }
  elseif ($prop == UrlHeader) {
    if ($0 != 2) {
      %error = Missing or excessive header parameter specified
    }
    elseif (0 ?* iswm $jsTry(%com, $JScript(UrlHeader), $escape($2).quote)) {
      %error = $gettok($v2, 2-, 32)
    }
    else {
      return $gettok($v2, 2-, 32)
    }
  }
  elseif (fuzzy* iswm $prop) {
    if ($0 < 2) {
      %error = Missing parameters
    }
    else {
      var %x = 2, %path, %res
      while (%x <= $0) {
        %path = %path $+ $escape($($ $+ %x, 2)).quote $+ $chr(44)
        inc %x
      }
      %res = $jsTry(%com, $JScript(fuzzy), %get, $left(%path, -1))

      if (0 ? iswm %res) {
        %error = $gettok(%res, 2-, 32)
      }
      elseif ($prop == fuzzy) {
        %get = %get $+ $gettok(%res, 2-, 32)
      }
      else {
        return $regsubex(%get, ^json, ) $+ $gettok(%res, 2-, 32)
      }
    }
  }
  if (!%error) {
    if (fuzzy* !iswm $prop) {
      %x = $iif($prop == toBvar, 3, 2)
      while (%x <= $0) {
        %i = $ [ $+ [ %x ] ]
        if ($len(%i)) {
          %get = $+(%get, [", $escape(%i), "])
          inc %x
        }
        else {
          %error = Empty index|item passed.
          break
        }
      }
    }
    if (!%error) {
      if ($prop == type) {
        if (0 ?* iswm $jsTry(%com, $JScript(typeof), %get)) {
          %error = $gettok($v2, 2-, 32)
        }
        else {
          return $gettok($v2, 2-, 32)
        }
      }
      elseif ($prop == length) {
        if (0 ?* iswm $jsTry(%com, $JScript(length), %get)) {
          %error = $gettok($v2, 2-, 32)
        }
        else {
          return $gettok($v2, 2-, 32)
        }
      }
      elseif ($prop == isParent) {
        if (0 ?* iswm $jsTry(%com, $JScript(isparent), %get)) {
          %error = $gettok($v2, 2-, 32)
        }
        else {
          return $iif($gettok($v2, 2-, 32), $true, $false)
        }
      }
      elseif ($prop == toBvar) {
        %file = $tempfile
        if (0 ?* iswm $jsTry(%com, $JScript(tofile), $escape(%file).quote, %get)) {
          %error = $gettok($v2, 2-, 32)
        }
        else {
          bread $qt(%file) 0 $file(%file) $2
        }
        if ($isfile(%file)) { .remove $qt(%file) }
      }
      elseif (0 ?* iswm $jsTry(%com, $JScript(get), %get)) {
        %error = $gettok($v2, 2-, 32)
        if (%error == Object or Array referenced) {
          %error = $null
          Debugger -s $+(%com,>$JSON) Result is an Object or Array; returning reference
          return %com $+ :: $+ $regsubex(%get, /^json/, )
        }
      }
      else {
        var %res = $gettok($v2, 2-, 32)
        Debugger -s $+(%com,>$JSON) %get references %res
        return %res
      }
    }
  }
  :error
  %error = $iif($error, $v1, %error)
  if (%error) {
    set -eu0 %JSONError
    if (%com && $com(%com)) {
      set -eu0 $+(%,%com,::Error) %error
    }
    var %r
    %x = 0
    while (%x < $0) {
      inc %x
      %r = $addtok(%r, $chr(32) $+ $ [ $+ [ %x ] ] , 44)
    }
    debugger -e $iif(%com && $com(%com),%com,0) $!JSON( $+ %r $+ ) $+ $+ $iif($prop,. $+ $prop) --RAISED-- %error
  }
}
alias JSONDebug {
  if ($isid) {
    return $iif($group(#JSONForMircDebug) == on, $true, $false)
  }
  elseif ($0) {
    tokenize 32 $iif($group(#JSONForMircDebug) == on, off, on)
  }
  if ($regex($1-,/^(?:on|enable)$/i)) {
    .enable #JSONForMircDebug
    debugger -i Debugger Now Enabled
  }
  elseif ($regex($1-, /^(?:off|disable)$/i)) {
    .disable #JSONForMircDebug
    if ($window(@JSONForMircDebug)) {
      close -@ @JSONForMircDebug
    }
  }
}
#JSONForMircDebug off
alias -l Debugger {
  if ($isid) return
  if (!$window(@JSONForMircDebug)) {
    window -zk0 @JSONForMircDebug
  }
  var %switches = -, %c
  if (-* iswm $1) {
    %switches = $1
    tokenize 32 $2-
  }
  if (e isincs %switches) {
    %c = 04
  }
  elseif (s isincs %switches) {
    %c = 12
  }
  else {
    %c = 03
  }
  var %n = $iif($1, $1, JSONForMirc)
  %n = $regsubex(%n, /^JSONHandler::, )
  aline -p @JSONForMircDebug $+($chr(3),%c,[,%n,],$chr(15)) $2-
}
#JSONForMircDebug end
alias -l Debugger return
menu @JSONForMircDebug {
  .Clear: clear -@ @JsonForMircDebug
  .Disable and Close: JSONDebug off
}
alias -l tempfile {
  var %n = 1
  while ($isfile($scriptdirJSONTmpFile $+ %n $+ .json)) {
    inc %n
  }
  return $scriptdirJSONTmpFile $+ %n $+ .json
}
alias -l escape {
  var %esc = $replace($1-,\,\\,",\")
  return $iif($prop == quote, $qt(%esc), %esc)
}
alias -l JScript {
  if (!$isid) return
  if (!$0) return (function(){status="init";json=null;url={m:"GET",u:null,h:[],d:null};response=null;var r,x=['MSXML2.SERVERXMLHTTP.6.0','MSXML2.SERVERXMLHTTP.3.0','MSXML2.SERVERXMLHTTP','MSXML2.XMLHTTP.6.0','MSXML2.XMLHTTP.3.0','Microsoft.XMLHTTP'],i;while(x.length){try{r=new ActiveXObject(x.shift());break}catch(e){}}xhr=r?function(){r.open(url.m,url.u,false);for(i=0;i<url.h.length;i+=1)r.setRequestHeader(url.h[i][0],url.h[i][1]);r.send(url.d);return(response=r).responseText}:function(){throw new Error("HTTP Request object not found")};read=function(f){var a=new ActiveXObject("ADODB.stream"),d;a.CharSet="utf-8";a.Open();a.LoadFromFile(f);if(a.EOF){a.close();throw new Error("No content in file")}d=a.ReadText();a.Close();return d;};write=function(f,d){var a=new ActiveXObject("ADODB.stream");a.CharSet="utf-8";a.Open();a.WriteText(d);a.SaveToFile(f,2);a.Close()};parse=function(t){if(/^[\],:{}\s]*$/.test((t=(String(t)).replace(/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,function(a){return'\\u'+('0000'+a.charCodeAt(0).toString(16)).slice(-4)})).replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,'@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,']').replace(/(?:^|:|,)(?:\s*\[)+/g,''))){return eval('('+t+')')}throw new SyntaxError('Unable to Parse: Invalid JSON')};fuzzy=function(){var a=Array.prototype.slice.call(arguments),b=a.shift(),c="",d=Object.prototype.toString.call(b),e,f,g,h,i;for(e=0;e<a.length;e+=1){f=a[e];if(b.hasOwnProperty(f)){if(typeof b[f]==="function")throw new TypeError("Reference points to a function");b=b[f];c+="[\""+f+"\"]"}else if(d==="[object Object]"){if(typeof f==="number")f=f.toString(10);f=f.toLowerCase();g=-1;i=!1;for(h in b){if(b.hasOwnProperty(h)&&typeof b[h]!=="function"){g+=1;if(h.toLowerCase()===f){b=b[h];c+="[\""+h+"\"]";i=!0;break}else if(g.toString(10)===f){b=b[h];c+="[\""+h+"\"]";i=!0;break}}}if(!i)throw new Error("No matching reference found");}else{throw new Error("Reference does not exist")}d=Object.prototype.toString.call(b)}return c}}());
  if ($1 == FileParse)     return if(status!=="init")throw new Error("Parse Not Pending");json=parse(read(@1@));status="done"
  if ($1 == UrlInit)       return if(status!=="init")throw new Error("JSON handler not ready");url.u=@1@;status="url"
  if ($1 == UrlMethod)     return if(status!=="url")throw new Error("URL Request Not Pending");url.m=@1@
  if ($1 == UrlHeader)     return if(status!=="url")throw new Error("URL Request Not Pending");url.h.push([@1@,@2@])
  if ($1 == UrlData)       return if(status!=="url")throw new Error("URL Request Not Pending");url.d=read(@1@)
  if ($1 == UrlParse)      return if(status!=="url")throw new Error("URL Request Not Pending");json=parse(xhr());status="done"
  if ($1 == UrlStatus)     return if(status!=="done")throw new Error("Data not parsed");if(!response)throw new Error("URL request not made");return response.status;
  if ($1 == UrlStatusText) return if(status!=="done")throw new Error("Data not parsed");if(!response)throw new Error("URL request not made");return response.statusText;
  if ($1 == UrlHeader)     return if(status!=="done")throw new Error("Data not parsed");if(!response)throw new Error("URL Request not made");return response.getResponseHeader(@1@)
  if ($1 == fuzzy)         return if(status!=="done")throw new Error("Data not parsed");return "1 "+fuzzy(@1@,@2@)
  if ($1 == typeof)        return if(status!=="done")throw new Error("Data not parsed");var i=@1@;if(i===undefined)throw new TypeError("Reference doesn't exist");if(i===null)return"1 null";var s=Object.prototype.toString.call(i);if(s==="[object Array]")return"1 array";if(s==="[object Object]")return"1 object";return "1 "+typeof(i)
  if ($1 == length)        return if(status!=="done")throw new Error("Data not parsed");var i=@1@;if(i===undefined)throw new TypeError("Reference doesn't exist");if(/^\[object (?:String|Array)\]$/.test(Object.prototype.toString.call(i)))return"1 "+i.length.toString(10);throw new Error("Reference is not a string or array");
  if ($1 == isparent)      return if(status!=="done")throw new Error("Data not parsed");var i=@1@;if(i===undefined)throw new TypeError("Reference doesn't exist");if(/^\[object (?:Object|Array)\]$/.test(Object.prototype.toString.call(i)))return"1 1";return"1 0"
  if ($1 == tofile)        return if(status!=="done")throw new Error("Data not parsed");var i=@2@;if(i===undefined)throw new TypeError("Reference doesn't exist");if(typeof i!=="string")throw new TypeError("Reference must be a string");write(@1@,i);
  if ($1 == get)           return if(status!=="done")throw new Error("Data not parsed");var i=@1@;if(i===undefined)throw new TypeError("Reference doesn't exist");if(i===null)return"1";if(/^\[object (?:Array|Object)\]$/.test(Object.prototype.toString.call(i)))throw new TypeError("Object or Array referenced");if(i.length>4000)throw new Error("Data would exceed mIRC's line length limit");if(typeof i == "boolean")return i?"1 1":"1 0";if(typeof i == "number")return "1 "+i.toString(10);return "1 "+i;
}
alias -l jsTry {
  if ($isid) {
    if ($0 < 2 || $prop == withError && $0 < 3) {
      return 0 Missing parameters
    }
    elseif (!$com($1)) {
      return 0 No such com
    }
    else {
      var %code = $2, %error, %n = 2, %o, %js
      if ($prop == withError) {
        %error = $3
        %n = 3
      }
      %o = %n
      while (%n < $0) {
        inc %n
        set -l $+(%, arg, $calc(%n - %o)) $eval($+($, %n), 2)
      }
      %code = $regsubex($regsubex(%code, /@(\d+)@/g, $var($+(%, arg, \t ),1).value), [\s;]+$, )
      %error = $regsubex($regsubex(%error, /@(\d+)@/g, $var($+(%, arg, \t ),1).value), [\s;]+$, )
      if (%code) %code = $v1 $+ ;
      if (%error) %error = $v1 $+ ;
      %js = (function(){error=null;try{ $+ %code $+ return"1 OK"}catch(e){ $+ %error $+ error=e.message;return"0 "+error}}())
      debugger $1>$jsTry Executing: %js
      if (!$com($1, eval, 1, bstr, %js) || $comerr) {
        return 0 Unable to execute specified javascript
      }
      return $com($1).result
    }
  }
}
